-lnsl -lsocket -lresolv
ex:	cc -o server server.c -lnsl -lsocket -lresolv
	If you still get errors, you could try further adding a -lxnet to the end of that command line. I don’t know what that does, exactly, but some people seem to need it.
------------------------
{
	# two tipes of sockets
		* Stream sockets:
			-open connection
			*- send() the data out
		* datagram sockets:
			- it use IP for routing, but they don't use TCP; they use the "User Datagram Protocol" UDP
			- dhcpcd (a DHCP client): multiplayer games, streaming audio, video conferencing, etc.
			- TFTP: sample application.
			*- Encapsulate the packet in the method of your choosing and sendto() it out 
		*** TFTP && DHCPCD are used to transfer binary applicaitions from one host to another!
			data can't be lost if you expect the applicaitions to work when it arrives!
		*
			- Application layer (tlenet, ftp, etc.)
			- Host-to-Host Transport layer (TCP, UDP)
			- Internet Layer (IP and routing)
			- Network access layer (Ethernet, wi-fi, or whatever)
}
{
	# IP adresses, -v 4 and 6
		* 
}
{
	struct addrinfo
	{
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC		:	to use IPv4 or Ipv6
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for "any"
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6		:This is where we start getting into the nitty-gritty details of what’s inside an IP address structure.
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // linked list, next node
	};
}









Words:
		perhaps you are wondering just what they are exactly.
		send() and recv() offer much greater control over your data transmission.